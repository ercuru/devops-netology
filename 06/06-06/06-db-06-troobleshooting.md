# Домашнее задание к занятию 6. «Troubleshooting»

## Задача 1
> 
> Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).
> 
> Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её 
> нужно прервать. 
> 
> Вы как инженер поддержки решили произвести эту операцию:
> 
> - напишите список операций, которые вы будете производить для остановки запроса пользователя;
> - предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.

### Решение 1


1. - проблемную операцию найдем через db.currentOp(). Поскольку мы знаем, что операция принадлежит конкретному пользователю, то вызов db.currentOp({ "$ownOps": true }) вернет операции этого пользователя
   - далее полученный opid передаём в качестве параметра в db.killOp() чтобы прервать операцию
2. - сначала сделал бы перестройку индексов
   - далее нужно понять долгие запросы когда стали долго выполнятся и выполняются ли они в разумный срок вообще
   - далее увеличить максимальное время для обработки - или как вариант наоборот установить предел для закрытия таких запросов, что переходят в "подвисание"

## Задача 2

> Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).
> 
> Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
> Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и
> увеличивается пропорционально количеству реплик сервиса. 
> 
> При масштабировании сервиса до N реплик вы увидели, что:
> 
> - сначала происходит рост отношения записанных значений к истекшим,
> - Redis блокирует операции записи.
> 
> Как вы думаете, в чём может быть проблема?
 
### Решение 2

- Предположу, что проблема в нехватки памяти. Проблема скорей всего в том что вся память занята истекшими в один и тот же момент ключами которые еще не удаленны. Так как Redis использует в основном однопоточную конструкцию, поэтому все запросы обслуживаются последовательно, в связи с этим пока не выполнится очистка, все операции записи блокируются

## Задача 3

> Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы
> пользователи начали жаловаться на ошибки вида:
> ```python
> InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
> ```
> 
> Как вы думаете, почему это начало происходить и как локализовать проблему?
> 
> Какие пути решения этой проблемы вы можете предложить?

### Решение 3

возможные варианты:
- большие запросы и нужно увеличивать параметр net_read_timeout
- малое значение connect_timeout - клиент за отведенное время не успевает установить соединение
- размер запроса превышает размер буфера и нужно проверить max_allowed_packet

Для решения можно попробовать увеличить значения connect_timeout, wait_timeout, net_write_timeout, net_read_timeout, max_allowed_packet

## Задача 4

> 
> Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
> большим объёмом данных лучше, чем MySQL.
> 
> После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
> 
> `postmaster invoked oom-killer`
> 
> Как вы думаете, что происходит?
> 
> Как бы вы решили эту проблему?
> 

### Решение 4

1) по ошибке можно предположить, что недостаток оперативной памяти имеет место быть
2) в качестве решения:
   - увеличение памяти
   - настроить параметры памяти в postgres:
     - work_mem - если нам нужно выполнить сложную сортировку, увеличьте значение work_mem для получения хороших результатов. Сортировка в памяти происходит намного быстрее, чем сортировка данных на диске. Установка очень высокого значения может стать причиной узкого места в памяти для нашей среды, поскольку этот параметр относится к операции сортировки пользователя.
     - shared_buffers - этот параметр устанавливает, сколько выделенной памяти будет использоваться PostgreSQL для кеширования.
     - wal_buffers - PostgreSQL сначала записывает записи в WAL (журнал пред записи) в буферы, а затем эти буферы сбрасываются на диск. Размер буфера по умолчанию, определенный wal_buffers, составляет 16 МБ. Но если у нас много одновременных подключений, то более высокое значение может повысить производительность.
     - maintenance_work_mem - это параметр памяти, используемый для задач обслуживания.
     - effective_cache_size - предоставляет оценку памяти, доступной для кэширования диска. Это всего лишь ориентир, а не точный объем выделенной памяти или кеша. Он не выделяет фактическую память, но сообщает оптимизатору объем кеша, доступный в ядре. Если значение этого параметра установлено слишком низким, планировщик запросов может принять решение не использовать некоторые индексы, даже если они будут полезны. Поэтому установка большого значения всегда имеет смысл.
